# -*- coding: utf-8 -*-
"""Seq.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZEjN9_spmPA9Tf7XyxZ3veEi1AlMV8IH
"""

import numpy as np                                     # linear algebra
import pandas as pd                                    # data processing, CSV file I/O (e.g. pd.read_csv)
import copy                                            #to copy list
from sklearn.model_selection import train_test_split   #to split dataset into train and test set
from sklearn.svm import SVC                            #to create svc instance
from sklearn.metrics import classification_report      #to create report for precision,recall,f1-score,accuracy
from sklearn import metrics                            #to get accuracy
from sklearn.model_selection import GridSearchCV       #to optimise the hyper-parameter
import math

from google.colab import drive
drive.mount("/content/drive")
path_to_data = "/content/drive/MyDrive/M1_2IS/Computational_Intelligence/"
df = pd.read_csv(path_to_data + "training_secondary_structure_train.csv")
df_test1 = pd.read_csv(path_to_data + "test_secondary_structure_casp12.csv")

#dataset 1
'''
df=df.head(5001)
df.head()
#print(df.info())
'''

#dataset 2
#df=df.head()
df.head()

#dataset 3
'''
df=df.head(50)
df.head()
'''

#dataset 1
'''
maxlen_seq = 12
input_seqs, target_seqs = df[['seq', 'sst8']][(df.len <= maxlen_seq) & (~df.has_nonstd_aa)].values.T
input_seqs, target_seqs = df[['seq', 'sst8']][(~df.has_nonstd_aa)].values.T
input_grams = seq2ngrams(input_seqs)
print(input_seqs[0:5])
'''

'''
#maxlen_seq = 50
#input_seqs, target_seqs = df[['seq', 'sst8']][(df['sst8'].apply(lambda x: len(x))<= maxlen_seq)].values.T
input_seqs, target_seqs = df[['seq', 'sst8']].values.T
print(input_seqs[0:8])
'''

#dataset 4
input_seqs, target_seqs = df[['seq', 'sst8']].values.T
input_seqs_test1, target_seqs_test1 = df_test1[['seq', 'sst8']].values.T


maxlen_seq = 50

input_seqs, target_seqs = df[['seq', 'sst8']].values.T
input_seqs, target_seqs = df_test1[['seq', 'sst8']][(df['sst8'].apply(lambda x: len(x))<= maxlen_seq)].values.T
print(input_seqs[0:5])



# maxlen_seq = 50
# input_seqs_test1, target_seqs_test1 = df_test1[['seq', 'sst8']][(df['sst8'].apply(lambda x: len(x))<= maxlen_seq)].values.T
# input_seqs, target_seqs = df[['seq', 'sst8']].values.T
# print(input_seqs[0:8])



print(input_seqs[0:5])
print(input_seqs_test1[0:5])

print(target_seqs[0:5])
print(target_seqs.size)

inputSeqs=[]
targetSeqs=[]
for i in range(input_seqs.size):
    j=0
    while(j<len(input_seqs[i])/128):
        start = j*128
        end = start+128
        inputSeqs.append(input_seqs[i][start:end])
        targetSeqs.append(target_seqs[i][start:end])
        j+=1
        
print(len(targetSeqs))
print(len(inputSeqs))

inputSeqs_test1=[]
targetSeqs_test1=[]
for i in range(input_seqs_test1.size):
    j=0
    while(j<len(input_seqs_test1[i])/128):
        start = j*128
        end = start+128
        inputSeqs_test1.append(input_seqs_test1[i][start:end])
        targetSeqs_test1.append(target_seqs_test1[i][start:end])
        j+=1
        
print(len(targetSeqs_test1))
print(len(inputSeqs_test1))

#for test data
for row in range(len(targetSeqs_test1)):
    secondary_lenth1 = len(targetSeqs_test1[row])
    primary_lenth1 = len(inputSeqs_test1[row])
    
    if(secondary_lenth1 != primary_lenth1):
        print("(",row,") Secondary_Structure ->", targetSeqs_test1[row]," Primary_Structure -> ",inputSeqs_test1[row])
    
print(len(inputSeqs_test1))

for row in range(len(targetSeqs)):
    secondary_lenth = len(targetSeqs[row])
    primary_lenth = len(inputSeqs[row])
    
    if(secondary_lenth != primary_lenth):
        print("(",row,") Secondary_Structure ->", targetSeqs[row]," Primary_Structure -> ",inputSeqs[row])
    
print(len(inputSeqs))

secondary_count = 0
primary_count = 0
dataCheck = "ACEDGFIHKMLNQPSRTWVY"
index=[]
for row in range(len(targetSeqs)):
    secondary_lenth = len(targetSeqs[row])
    primary_lenth = len(inputSeqs[row])
    secondary_count = secondary_count + secondary_lenth
    primary_count = primary_count + primary_lenth
    if(secondary_lenth != primary_lenth):
        print("(",row,") Secondary_Structure ->", targetSeqs[row]," Primary_Structure -> ",inputSeqs[row])
    for col in range(len(inputSeqs[row])):
        #print("before :",inputSeqs[row][col])
        if len(inputSeqs[row])<2:
            index.append(row)
        if dataCheck.find(inputSeqs[row][col])==-1:
            #print("after :",inputSeqs[row][col])
            index.append(row)
           # print("Row : "+str(row)+"have been deleted for having unknown data")
            break
            

inputSeqs =np.delete(inputSeqs,index)
targetSeqs =np.delete(targetSeqs,index)
        
print("count of secondary structure : ",secondary_count)
print("count of primary structure : ",primary_count)
print("size of primary structure : ",len(inputSeqs))

def split(sequence): 
    return [char for char in sequence]

primary_split = []
secondary_split = []
for row in range(int(len(targetSeqs)/1)):
    primary_split.append(split(inputSeqs[row]))
    secondary_split.append(split(targetSeqs[row]))
    
print(len(primary_split))

primary_split_test1 = []
secondary_split_test1 = []
for row in range(int(len(targetSeqs_test1)/1)):
    primary_split_test1.append(split(inputSeqs_test1[row]))
    secondary_split_test1.append(split(targetSeqs_test1[row]))
    
print(len(primary_split_test1))

def orthogonal_primary(arg):
    switch = {
        'A' : np.array([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),  # 20 amino acids
        'C' : np.array([0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'E' : np.array([0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'D' : np.array([0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'G' : np.array([0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'F' : np.array([0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'I' : np.array([0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]),
        'H' : np.array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0]),
        'K' : np.array([0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]),
        'M' : np.array([0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]),
        'L' : np.array([0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0]),
        'N' : np.array([0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]),
        'Q' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]),
        'P' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]),
        'S' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]),
        'R' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0]),
        'T' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]),
        'W' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0]),
        'V' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0]),
        'Y' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]),
        'X' : np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
    }
    
    return switch.get(arg)

def orthogonal_secondary(arg):
    switch = {
        'H' : 0,                    # H= α-helix
        'C' : 1,                    # C= Loops and irregular elements
        'E' : 2,                    # E= β-strand
        'B' : 3,                    # B= β-bridge
        'G' : 4,                    # G= 3-helix
        'I' : 5,                    # I= π-helix
        'T' : 6,                    # T= Turn
        'S' : 7                     # S= Bend
    }
    
    return switch.get(arg)

for row in range(len(primary_split)):  
    sequence = primary_split[row]
    for col in range(len(sequence)):
        #print(sequence[col])
        sequence[col] = orthogonal_primary(sequence[col])
        #print(sequence[col])

#for test data
for row in range(len(primary_split_test1)):  
    sequence1 = primary_split_test1[row]
    for col in range(len(sequence1)):
        #print(sequence[col])
        sequence1[col] = orthogonal_primary(sequence1[col])
        #print(sequence[col])

for row in range(len(secondary_split)):  
    sequenceS = secondary_split[row]
    for col in range(len(sequenceS)):
        sequenceS[col] = orthogonal_secondary(sequenceS[col])

#for test data
for row in range(len(secondary_split_test1)):  
    sequenceS1 = secondary_split_test1[row]
    for col in range(len(sequenceS1)):
        sequenceS1[col] = orthogonal_secondary(sequenceS1[col])

primary_split_test1[0:2]

#secondary_split[0:5]

def graph_sum2(seq1,seq2):
    result=[None]*len(seq1)
    for col in range(len(seq1)):
        result[col] =  seq1[col]+seq2[col]
    return result


def graph_sum3(seq1,seq2,seq3):
    result=[None]*len(seq1)
    for col in range(len(seq1)):
        result[col] =  seq1[col]+seq2[col]+seq3[col]
    return result

graph_input = copy.deepcopy(primary_split)
for row in range(len(primary_split)):
    sequence = primary_split[row]
    graph_input[row][0]=graph_sum2(sequence[0],sequence[1])
    graph_input[row][len(sequence)-1]=graph_sum2(sequence[len(sequence)-1],sequence[len(sequence)-2])
    for col in range(1,len(sequence)-1):
        graph_input[row][col] = graph_sum3(sequence[col-1],sequence[col],sequence[col+1])
        
graph_input[0:5]

#for test data
graph_input_test1 = copy.deepcopy(primary_split_test1)
temp = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
for row in range(len(primary_split_test1)):
    sequence1 = primary_split_test1[row]
    if len(sequence1)>1:
        graph_input_test1[row][0]=graph_sum2(sequence1[0],sequence1[1])
        graph_input_test1[row][len(sequence1)-1]=graph_sum2(sequence1[len(sequence1)-1],sequence1[len(sequence1)-2])
        for col in range(1,len(sequence1)-1):
            graph_input_test1[row][col] = graph_sum3(sequence1[col-1],sequence1[col],sequence1[col+1])
           
graph_input_test1[0:5]

def targetY(data_list):
    Y = []
    for i in range(len(data_list)):
        for j  in range(len(data_list[i])):
            Y.append(data_list[i][j])
    return Y

y_label = targetY(secondary_split)
y_label_test1 = targetY(secondary_split_test1)

print(len(y_label))
print(y_label[0:5])

print(len(y_label_test1))
print(y_label_test1[0:5])

def window_padding_data(size, sequence):
    num = int(size/2)
    #print("initial :",sequence[0])
    #print("")
    zeros = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    for i in range(len(sequence)):
        for j in range(num):
            sequence[i].append(zeros)
            sequence[i].insert(0, zeros)
            #print(sequence[i])
            #print("")
            
    X = []
    temp = []

    for k in range(len(sequence)):
        #print(sequence[k])
        for l in range(len(sequence[k])-(size-1)):
            temp = sequence[k][l:l+size]
           # print(temp)
            X.append(temp)
            temp = []

    return X

X = window_padding_data(11,graph_input)
print(len(X))
X[0:5]

X_test1 = window_padding_data(11,graph_input_test1)
print(len(X_test1))
X_test1[0:5]

np.set_printoptions(threshold=np.inf)
X = np.array(X)
y_label = np.array(y_label)
X = X.reshape(len(X),11*20)
print(X[0:5])
print("X_train length :",len(X))
print("y_label length :",len(y_label))

X_test1 = np.array(X_test1)
y_label_test1 = np.array(y_label_test1)
X_test1 = X_test1.reshape(len(X_test1),11*20)
print(X_test1[0:5])
print("X_train length :",len(X_test1))
print("y_label length :",len(y_label_test1))

X_train = X
y_train = y_label
X_test = X_test1
y_test = y_label_test1

dictp = {'C':0,'gamma':0,'kernel':"none",'accuracy':0}

for i in range(1,101):
    X_train, X_test, y_train, y_test = train_test_split(X, y_label, test_size = 0.20)
svc = SVC(kernel='rbf', gamma = 0.1, C=1.5)
svc.fit(X_train, y_train)
y_pred = svc.predict(X_test)
y_true = y_test
  
print("Accuracy = ",metrics.accuracy_score(y_test, y_pred)*100)
print(classification_report(y_true,y_pred))